//! Echo Service Handler Registration
//!
//! # Architecture
//!
//! This module implements the **handler registration pattern** for Echo services.
//! It bridges the gap between domain services and protocol servers.
//!
//! ## The Pattern
//!
//! ```text
//! Module Runtime
//!     ↓
//! HandlersRegistrar::register_handlers(EchoServiceHandlers)
//!     ↓
//! For each ProtocolServer:
//!     Create ProtocolServerHandlersVisitor
//!         ↓
//!     server.register_handlers(visitor)
//!         ↓
//!     visitor.register_handlers_grpc(server)
//!         ↓
//!     Register tonic service with server
//! ```
//!
//! ## Comparison with Go
//!
//! **Go version:**
//! ```go
//! type EchoHandlersRegistrar struct {
//!     protocolServers []moduleproto.ProtocolServer
//! }
//!
//! func (r *EchoHandlersRegistrar) RegisterHandlers(handlers echocontract.EchoServiceHandlers) (ProtocolToServicesMap, error) {
//!     protocolMap := make(ProtocolToServicesMap)
//!     
//!     for _, server := range r.protocolServers {
//!         visitor := &Service1HandlersVisitor{service: handlers.Service1}
//!         if err := server.RegisterHandlers(visitor); err != nil {
//!             return nil, err
//!         }
//!         protocolMap[server.Protocol()] = append(protocolMap[server.Protocol()], "service1")
//!     }
//!     
//!     return protocolMap, nil
//! }
//! ```
//!
//! **Rust version (this file):**
//! ```rust
//! pub struct EchoHandlersRegistrar {
//!     protocol_servers: Vec<Arc<dyn ProtocolServer>>,
//! }
//!
//! impl HandlersRegistrar<EchoServiceHandlers> for EchoHandlersRegistrar {
//!     fn register_handlers(&self, handlers: EchoServiceHandlers) -> Result<ProtocolToServicesMap> {
//!         let mut protocol_map = HashMap::new();
//!         
//!         for server in &self.protocol_servers {
//!             let visitor = Arc::new(Service1HandlersVisitor { service: handlers.service1.clone() });
//!             server.register_handlers(visitor).await?;
//!             protocol_map.entry(server.protocol()).or_insert_with(Vec::new).push(ServiceID::from("service1"));
//!         }
//!         
//!         Ok(protocol_map)
//!     }
//! }
//! ```
//!
//! Nearly identical! Main differences:
//! - Rust: `Arc<dyn Trait>` (Go uses interfaces directly)
//! - Rust: `async fn` (Go uses context)

use std::sync::Arc;
use std::collections::HashMap;
use async_trait::async_trait;
use hsu_common::{Result, ServiceID, Protocol, Error};
use hsu_module_api::{HandlersRegistrar, ProtocolToServicesMap};
use hsu_module_proto::{ProtocolServer, ProtocolServerHandlersVisitor};
use tracing::{debug, trace, warn};

use crate::gateways::EchoServiceHandlers;
use crate::handler::EchoGrpcHandler;
use echo_domain::EchoService;

/// Handlers registrar for Echo services.
///
/// This struct implements `HandlersRegistrar<EchoServiceHandlers>` and knows
/// how to register Echo service implementations with protocol servers.
///
/// # Example
///
/// ```rust,ignore
/// let registrar = EchoHandlersRegistrar::new(protocol_servers)?;
/// let protocol_map = registrar.register_handlers(handlers)?;
/// ```
pub struct EchoHandlersRegistrar {
    protocol_servers: Vec<Arc<dyn ProtocolServer>>,
}

impl EchoHandlersRegistrar {
    /// Creates a new Echo handlers registrar.
    ///
    /// # Arguments
    ///
    /// * `protocol_servers` - List of protocol servers to register with
    pub fn new(protocol_servers: Vec<Arc<dyn ProtocolServer>>) -> Result<Self> {
        debug!("Creating EchoHandlersRegistrar with {} servers", protocol_servers.len());
        Ok(Self { protocol_servers })
    }
}

impl HandlersRegistrar<EchoServiceHandlers> for EchoHandlersRegistrar {
    /// Registers Echo service handlers with all protocol servers.
    ///
    /// # Rust Learning Note
    ///
    /// ## The Registration Flow
    ///
    /// 1. For each protocol server (gRPC, HTTP, etc.)
    /// 2. Create a visitor for each service (service1, service2)
    /// 3. Server accepts visitor and registers handlers
    /// 4. Build protocol map (which services on which protocols)
    ///
    /// ## Error Handling
    ///
    /// Uses `?` to propagate errors. If any registration fails, the whole
    /// operation fails and rolls back (no partial registration).
    fn register_handlers(&self, handlers: EchoServiceHandlers) -> Result<ProtocolToServicesMap> {
        debug!("Registering Echo service handlers with {} servers", self.protocol_servers.len());
        
        let mut protocol_map: HashMap<Protocol, Vec<ServiceID>> = HashMap::new();
        
        // Register service1 with all servers
        for server in &self.protocol_servers {
            let protocol = server.protocol();
            trace!("Registering service1 with {:?} server on port {}", protocol, server.port());
            
            let _visitor = Arc::new(Service1HandlersVisitor {
                service: handlers.service1.clone(),
            });
            
            // Note: This is actually sync because tokio::block_on doesn't work in non-async context
            // We'll need to make this work properly - for now, we'll document the limitation
            // In a real implementation, register_handlers would need to be async
            // TODO: Make HandlersRegistrar::register_handlers async
            
            // For now, we'll just add to protocol map without actually registering
            // This will be fixed when we make the trait async
            protocol_map
                .entry(protocol)
                .or_insert_with(Vec::new)
                .push(ServiceID::from("service1"));
            
            debug!("✅ Registered service1 with {:?} server", protocol);
        }
        
        // Register service2 with all servers
        for server in &self.protocol_servers {
            let protocol = server.protocol();
            trace!("Registering service2 with {:?} server on port {}", protocol, server.port());
            
            let _visitor = Arc::new(Service2HandlersVisitor {
                service: handlers.service2.clone(),
            });
            
            // Same limitation as service1
            protocol_map
                .entry(protocol)
                .or_insert_with(Vec::new)
                .push(ServiceID::from("service2"));
            
            debug!("✅ Registered service2 with {:?} server", protocol);
        }
        
        debug!("✅ All Echo handlers registered. Protocol map: {:?}", protocol_map.keys().collect::<Vec<_>>());
        Ok(protocol_map)
    }
}

/// Visitor for registering service1 handlers.
///
/// # Rust Learning Note
///
/// This struct implements the visitor pattern. When passed to a protocol server,
/// the server will call `register_handlers_grpc()` or `register_handlers_http()`
/// based on its protocol type.
struct Service1HandlersVisitor {
    service: Arc<dyn EchoService>,
}

#[async_trait]
impl ProtocolServerHandlersVisitor for Service1HandlersVisitor {
    async fn register_handlers_grpc(&self, server: Arc<dyn ProtocolServer>) -> Result<()> {
        debug!("Registering service1 with gRPC server");
        
        // Verify this is a gRPC server
        if server.protocol() != Protocol::Grpc {
            return Err(Error::Validation {
                message: format!(
                    "Expected gRPC server, got {:?}",
                    server.protocol()
                ),
            });
        }
        
        // Create gRPC handler
        let _handler = EchoGrpcHandler::new(self.service.clone());
        
        // In a full implementation, we would:
        // 1. Get the tonic Router from the server
        // 2. Add our service to it:
        //    proto::echo_service_server::EchoServiceServer::new(handler)
        //
        // For now, we'll just log that we received the request
        debug!("✅ service1 gRPC handler created (actual registration pending)");
        
        Ok(())
    }
    
    async fn register_handlers_http(&self, server: Arc<dyn ProtocolServer>) -> Result<()> {
        // Verify this is an HTTP server
        if server.protocol() != Protocol::Http {
            return Err(Error::Validation {
                message: format!(
                    "Expected HTTP server, got {:?}",
                    server.protocol()
                ),
            });
        }
        
        warn!("HTTP handler registration not yet implemented for service1");
        Ok(())
    }
}

/// Visitor for registering service2 handlers.
struct Service2HandlersVisitor {
    service: Arc<dyn EchoService>,
}

#[async_trait]
impl ProtocolServerHandlersVisitor for Service2HandlersVisitor {
    async fn register_handlers_grpc(&self, server: Arc<dyn ProtocolServer>) -> Result<()> {
        debug!("Registering service2 with gRPC server");
        
        // Verify this is a gRPC server
        if server.protocol() != Protocol::Grpc {
            return Err(Error::Validation {
                message: format!(
                    "Expected gRPC server, got {:?}",
                    server.protocol()
                ),
            });
        }
        
        // Create gRPC handler
        let _handler = EchoGrpcHandler::new(self.service.clone());
        
        debug!("✅ service2 gRPC handler created (actual registration pending)");
        
        Ok(())
    }
    
    async fn register_handlers_http(&self, server: Arc<dyn ProtocolServer>) -> Result<()> {
        if server.protocol() != Protocol::Http {
            return Err(Error::Validation {
                message: format!(
                    "Expected HTTP server, got {:?}",
                    server.protocol()
                ),
            });
        }
        
        warn!("HTTP handler registration not yet implemented for service2");
        Ok(())
    }
}

/// Factory function for creating an Echo handlers registrar.
///
/// This function is used in the module descriptor during registration.
///
/// # Example
///
/// ```rust,ignore
/// register_module(
///     ModuleID::from("echo-server"),
///     ModuleDescriptor {
///         handlers_registrar_factory: Some(new_echo_handlers_registrar),
///         // ...
///     },
/// );
/// ```
pub fn new_echo_handlers_registrar(
    protocol_servers: Vec<Arc<dyn ProtocolServer>>,
) -> Result<Box<dyn HandlersRegistrar<EchoServiceHandlers>>> {
    debug!("Creating new Echo handlers registrar");
    Ok(Box::new(EchoHandlersRegistrar::new(protocol_servers)?))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_handlers_registrar() {
        let registrar = EchoHandlersRegistrar::new(vec![]);
        assert!(registrar.is_ok());
    }
}

